{"version":3,"file":"index.js","sources":["../src/constants.ts","../src/validators.ts","../src/index.ts"],"sourcesContent":["export const JWT_ALG = 'ES256K-R'\nexport const DID_FORMAT = /^did:([a-zA-Z0-9_]+):([:[a-zA-Z0-9_.-]+)(\\/[^#]*)?(#.*)?$/\nexport const JWT_FORMAT = /^[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*$/\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1'\nexport const DEFAULT_VC_TYPE = 'VerifiableCredential'\nexport const DEFAULT_VP_TYPE = 'VerifiablePresentation'\n","import {\n  DID_FORMAT,\n  DEFAULT_CONTEXT,\n  DEFAULT_VC_TYPE,\n  DEFAULT_VP_TYPE,\n  JWT_FORMAT\n} from './constants'\nimport { CredentialSubject } from './types'\n\nexport function validateJwtFormat(value: string): void {\n  if (!value.match(JWT_FORMAT)) {\n    throw new TypeError(`\"${value}\" is not a valid JWT format`)\n  }\n}\n\n// The main scenario we want to guard against is having a timestamp in milliseconds\n// instead of seconds (ex: from new Date().getTime()).\n// We will check the number of digits and assume that any number with 12 or more\n// digits is a millisecond timestamp.\n// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)\n// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)\n// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)\nexport function validateTimestamp(value: number): void {\n  if (!(Number.isInteger(value) && value < 100000000000)) {\n    throw new TypeError(`\"${value}\" is not a unix timestamp in seconds`)\n  }\n}\n\nexport function validateContext(value: string[]): void {\n  if (value.length < 1 || !value.includes(DEFAULT_CONTEXT)) {\n    throw new TypeError(\n      `@context is missing default context \"${DEFAULT_CONTEXT}\"`\n    )\n  }\n}\n\nexport function validateVcType(value: string[]): void {\n  if (value.length < 1 || !value.includes(DEFAULT_VC_TYPE)) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VC_TYPE}\"`)\n  }\n}\n\nexport function validateVpType(value: string[]): void {\n  if (value.length < 1 || !value.includes(DEFAULT_VP_TYPE)) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VP_TYPE}\"`)\n  }\n}\n\nexport function validateCredentialSubject(value: CredentialSubject): void {\n  if (Object.keys(value).length === 0) {\n    throw new TypeError('credentialSubject must not be empty')\n  }\n}\n","import { createJWT, verifyJWT } from 'did-jwt'\nimport { JWT_ALG, DEFAULT_CONTEXT, DEFAULT_VC_TYPE } from './constants'\nimport * as validators from './validators'\nimport {\n  VerifiableCredentialPayload,\n  Issuer,\n  PresentationPayload\n} from './types'\nimport { DIDDocument } from 'did-resolver'\n\nexport {\n  Issuer,\n  VerifiableCredentialPayload,\n  PresentationPayload,\n}\n\ninterface Resolvable {\n  resolve: (did: string) => Promise<DIDDocument | null>\n}\n\nexport async function createVerifiableCredential(\n  payload: VerifiableCredentialPayload,\n  issuer: Issuer\n): Promise<string> {\n  validateVerifiableCredentialAttributes(payload)\n  return createJWT(payload, {\n    issuer: issuer.did,\n    signer: issuer.signer,\n    alg: issuer.alg || JWT_ALG\n  })\n}\n\nexport async function createPresentation(\n  payload: PresentationPayload,\n  issuer: Issuer\n): Promise<string> {\n  validatePresentationAttributes(payload)\n  return createJWT(payload, {\n    issuer: issuer.did,\n    signer: issuer.signer,\n    alg: issuer.alg || JWT_ALG\n  })\n}\n\nexport function validateVerifiableCredentialAttributes(\n  payload: VerifiableCredentialPayload\n): void {\n  validators.validateContext(payload.vc['@context'])\n  validators.validateVcType(payload.vc.type)\n  validators.validateCredentialSubject(payload.vc.credentialSubject)\n  if (payload.nbf) validators.validateTimestamp(payload.nbf)\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validatePresentationAttributes(payload: PresentationPayload): void {\n  validators.validateContext(payload.vp['@context'])\n  validators.validateVpType(payload.vp.type)\n  if (payload.vp.verifiableCredential.length < 1) {\n    throw new TypeError('vp.verifiableCredential must not be empty')\n  }\n  for (const vc of payload.vp.verifiableCredential) {\n    validators.validateJwtFormat(vc)\n  }\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nfunction isLegacyAttestationFormat(payload: any): boolean {\n  // payload is an object and has all the required fields of old attestation format\n  return payload instanceof Object && payload.sub && payload.iss && payload.claim && payload.iat\n}\n\nfunction attestationToVcFormat(payload: any): VerifiableCredentialPayload {\n  const { iat, nbf, claim, vc, ...rest } = payload\n  const result:VerifiableCredentialPayload = {\n    ...rest,\n    nbf: nbf ? nbf : iat,\n    vc: {\n      '@context': [DEFAULT_CONTEXT],\n      type: [DEFAULT_VC_TYPE],\n      credentialSubject: payload.claim\n    }\n  }\n  if (vc) payload.issVc = vc\n  return result\n}\n\nexport async function verifyCredential(vc: string, resolver: Resolvable): Promise<any> {\n  const verified = await verifyJWT(vc, { resolver })\n  if(isLegacyAttestationFormat(verified.payload)) {\n    verified.payload = attestationToVcFormat(verified.payload)\n  }\n  validateVerifiableCredentialAttributes(verified.payload)\n  return verified\n}\n\nexport async function verifyPresentation(presentation: string, resolver: Resolvable): Promise<any> {\n  const verified = await verifyJWT(presentation, { resolver })\n  validatePresentationAttributes(verified.payload)\n  return verified\n}"],"names":["JWT_FORMAT","DEFAULT_CONTEXT","DEFAULT_VC_TYPE","DEFAULT_VP_TYPE","validateJwtFormat","value","match","TypeError","validateTimestamp","Number","isInteger","validateContext","length","includes","validateVerifiableCredentialAttributes","payload","validators","vc","type","Object","keys","credentialSubject","nbf","exp","validatePresentationAttributes","vp","verifiableCredential","presentation","resolver","verifyJWT","verified","sub","iss","claim","iat","result","issVc","attestationToVcFormat","issuer","createJWT","did","signer","alg"],"mappings":"yBAEaA,EAAa,2DACbC,EAAkB,yCAClBC,EAAkB,uBAClBC,EAAkB,kCCIfC,EAAkBC,OAC3BA,EAAMC,MAAMN,SACT,IAAIO,cAAcF,0CAWZG,EAAkBH,QAC1BI,OAAOC,UAAUL,IAAUA,EAAQ,YACjC,IAAIE,cAAcF,mDAIZM,EAAgBN,MAC1BA,EAAMO,OAAS,IAAMP,EAAMQ,SAASZ,SAChC,IAAIM,kDACgCN,gBCa9Ba,EACdC,GAEAC,EAA2BD,EAAQE,GAAG,sBDXTZ,MACzBA,EAAMO,OAAS,IAAMP,EAAMQ,SAASX,SAChC,IAAIK,sCAAsCL,OCUlDc,CAA0BD,EAAQE,GAAGC,eDAGb,MACN,IAA9Bc,OAAOC,KCA0BL,EAAQE,GAAGI,mBDAzBT,aACf,IAAIL,UAAU,uCCDtBS,GACID,EAAQO,KAAKN,EAA6BD,EAAQO,KAClDP,EAAQQ,KAAKP,EAA6BD,EAAQQ,cAGxCC,EAA+BT,MAC7CC,EAA2BD,EAAQU,GAAG,sBDbTpB,MACzBA,EAAMO,OAAS,IAAMP,EAAMQ,SAASV,SAChC,IAAII,sCAAsCJ,OCYlDa,CAA0BD,EAAQU,GAAGP,MACjCH,EAAQU,GAAGC,qBAAqBd,OAAS,QACrC,IAAIL,UAAU,iDAEjB,UAAYQ,EAAQU,GAAGC,qCAC1BV,QAEED,EAAQQ,KAAKP,EAA6BD,EAAQQ,yCAgCfI,EAAsBC,8BACtCC,YAAUF,EAAc,UAAEC,mBAA3CE,UACNN,EAA+BM,EAASf,SACjCe,0EAZ8Bb,EAAYW,8BAC1BC,YAAUZ,EAAI,UAAEW,mBAAjCE,GArBR,IAAmCf,SAAAA,EAsBJe,EAASf,mBApBZI,QAAUJ,EAAQgB,KAAOhB,EAAQiB,KAAOjB,EAAQkB,OAASlB,EAAQmB,MAqBzFJ,EAASf,QAlBb,SAA+BA,wLAEvBoB,EAAqChB,oBAEzCG,IAAKA,GAAYY,EACjBjB,GAAI,YACU,CAAChB,GACbiB,KAAM,CAAChB,GACPmB,kBAAmBN,EAAQkB,gBAG3BhB,IAAIF,EAAQqB,MAAQnB,GACjBkB,EAMcE,CAAsBP,EAASf,UAEpDD,EAAuCgB,EAASf,SACzCe,4EA3DPf,EACAuB,cAEAd,EAA+BT,mBACxBwB,YAAUxB,EAAS,CACxBuB,OAAQA,EAAOE,IACfC,OAAQH,EAAOG,OACfC,IAAKJ,EAAOI,KFxCO,8FEqBrB3B,EACAuB,cAEAxB,EAAuCC,mBAChCwB,YAAUxB,EAAS,CACxBuB,OAAQA,EAAOE,IACfC,OAAQH,EAAOG,OACfC,IAAKJ,EAAOI,KF5BO"}