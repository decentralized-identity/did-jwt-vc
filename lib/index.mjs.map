{"version":3,"file":"index.mjs","sources":["../src/constants.ts","../src/validators.ts","../src/index.ts"],"sourcesContent":["export const JWT_ALG = 'ES256K-R'\nexport const DID_FORMAT = /^did:([a-zA-Z0-9_]+):([:[a-zA-Z0-9_.-]+)(\\/[^#]*)?(#.*)?$/\nexport const JWT_FORMAT = /^[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*$/\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1'\nexport const DEFAULT_VC_TYPE = 'VerifiableCredential'\nexport const DEFAULT_VP_TYPE = 'VerifiablePresentation'\n","import {\n  DID_FORMAT,\n  DEFAULT_CONTEXT,\n  DEFAULT_VC_TYPE,\n  DEFAULT_VP_TYPE,\n  JWT_FORMAT\n} from './constants'\nimport { CredentialSubject } from './types'\n\nexport function validateJwtFormat(value: string): void {\n  if (!value.match(JWT_FORMAT)) {\n    throw new TypeError(`\"${value}\" is not a valid JWT format`)\n  }\n}\n\n// The main scenario we want to guard against is having a timestamp in milliseconds\n// instead of seconds (ex: from new Date().getTime()).\n// We will check the number of digits and assume that any number with 12 or more\n// digits is a millisecond timestamp.\n// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)\n// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)\n// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)\nexport function validateTimestamp(value: number): void {\n  if (!(Number.isInteger(value) && value < 100000000000)) {\n    throw new TypeError(`\"${value}\" is not a unix timestamp in seconds`)\n  }\n}\n\nexport function validateContext(value: string[]): void {\n  if (value.length < 1 || !value.includes(DEFAULT_CONTEXT)) {\n    throw new TypeError(\n      `@context is missing default context \"${DEFAULT_CONTEXT}\"`\n    )\n  }\n}\n\nexport function validateVcType(value: string[]): void {\n  if (value.length < 1 || !value.includes(DEFAULT_VC_TYPE)) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VC_TYPE}\"`)\n  }\n}\n\nexport function validateVpType(value: string[]): void {\n  if (value.length < 1 || !value.includes(DEFAULT_VP_TYPE)) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VP_TYPE}\"`)\n  }\n}\n\nexport function validateCredentialSubject(value: CredentialSubject): void {\n  if (Object.keys(value).length === 0) {\n    throw new TypeError('credentialSubject must not be empty')\n  }\n}\n","import { createJWT, verifyJWT } from 'did-jwt'\nimport { JWT_ALG, DEFAULT_CONTEXT, DEFAULT_VC_TYPE } from './constants'\nimport * as validators from './validators'\nimport {\n  VerifiableCredentialPayload,\n  Issuer,\n  PresentationPayload\n} from './types'\nimport { DIDDocument } from 'did-resolver'\n\nexport {\n  Issuer,\n  VerifiableCredentialPayload,\n  PresentationPayload,\n}\n\ninterface Resolvable {\n  resolve: (did: string) => Promise<DIDDocument | null>\n}\n\nexport async function createVerifiableCredential(\n  payload: VerifiableCredentialPayload,\n  issuer: Issuer\n): Promise<string> {\n  validateVerifiableCredentialAttributes(payload)\n  return createJWT(payload, {\n    issuer: issuer.did,\n    signer: issuer.signer,\n    alg: issuer.alg || JWT_ALG\n  })\n}\n\nexport async function createPresentation(\n  payload: PresentationPayload,\n  issuer: Issuer\n): Promise<string> {\n  validatePresentationAttributes(payload)\n  return createJWT(payload, {\n    issuer: issuer.did,\n    signer: issuer.signer,\n    alg: issuer.alg || JWT_ALG\n  })\n}\n\nexport function validateVerifiableCredentialAttributes(\n  payload: VerifiableCredentialPayload\n): void {\n  validators.validateContext(payload.vc['@context'])\n  validators.validateVcType(payload.vc.type)\n  validators.validateCredentialSubject(payload.vc.credentialSubject)\n  if (payload.nbf) validators.validateTimestamp(payload.nbf)\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validatePresentationAttributes(payload: PresentationPayload): void {\n  validators.validateContext(payload.vp['@context'])\n  validators.validateVpType(payload.vp.type)\n  if (payload.vp.verifiableCredential.length < 1) {\n    throw new TypeError('vp.verifiableCredential must not be empty')\n  }\n  for (const vc of payload.vp.verifiableCredential) {\n    validators.validateJwtFormat(vc)\n  }\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nfunction isLegacyAttestationFormat(payload: any): boolean {\n  // payload is an object and has all the required fields of old attestation format\n  return payload instanceof Object && payload.sub && payload.iss && payload.claim && payload.iat\n}\n\nfunction attestationToVcFormat(payload: any): VerifiableCredentialPayload {\n  const { iat, nbf, claim, vc, ...rest } = payload\n  const result:VerifiableCredentialPayload = {\n    ...rest,\n    nbf: nbf ? nbf : iat,\n    vc: {\n      '@context': [DEFAULT_CONTEXT],\n      type: [DEFAULT_VC_TYPE],\n      credentialSubject: payload.claim\n    }\n  }\n  if (vc) payload.issVc = vc\n  return result\n}\n\nexport async function verifyCredential(vc: string, resolver: Resolvable): Promise<any> {\n  const verified = await verifyJWT(vc, { resolver })\n  if(isLegacyAttestationFormat(verified.payload)) {\n    verified.payload = attestationToVcFormat(verified.payload)\n  }\n  validateVerifiableCredentialAttributes(verified.payload)\n  return verified\n}\n\nexport async function verifyPresentation(presentation: string, resolver: Resolvable): Promise<any> {\n  const verified = await verifyJWT(presentation, { resolver })\n  validatePresentationAttributes(verified.payload)\n  return verified\n}"],"names":["const","JWT_FORMAT","DEFAULT_CONTEXT","DEFAULT_VC_TYPE","DEFAULT_VP_TYPE","validateJwtFormat","value","match","TypeError","validateTimestamp","Number","isInteger","validateContext","length","includes","verifyPresentation","presentation","resolver","verifyJWT","verified","validatePresentationAttributes","payload","verifyCredential","vc","Object","sub","iss","claim","iat","result","nbf","type","credentialSubject","issVc","attestationToVcFormat","validateVerifiableCredentialAttributes","createPresentation","issuer","createJWT","did","signer","alg","createVerifiableCredential","validators","keys","exp","vp","verifiableCredential"],"mappings":"mDAAOA,IAEMC,EAAa,2DACbC,EAAkB,yCAClBC,EAAkB,uBAClBC,EAAkB,kCCIfC,EAAkBC,OAC3BA,EAAMC,MAAMN,SACT,IAAIO,cAAcF,0CAWZG,EAAkBH,QAC1BI,OAAOC,UAAUL,IAAUA,EAAQ,YACjC,IAAIE,cAAcF,mDAIZM,EAAgBN,MAC1BA,EAAMO,OAAS,IAAMP,EAAMQ,SAASZ,SAChC,IAAIM,kDACgCN,WCgExBa,WAAmBC,EAAsBC,8BACtCC,EAAUF,EAAc,UAAEC,mBAA3CE,UACNC,EAA+BD,EAASE,SACjCF,wCAZaG,WAAiBC,EAAYN,8BAC1BC,EAAUK,EAAI,UAAEN,mBAAjCE,GArBR,IAAmCE,SAAAA,EAsBJF,EAASE,mBApBZG,QAAUH,EAAQI,KAAOJ,EAAQK,KAAOL,EAAQM,OAASN,EAAQO,MAqBzFT,EAASE,QAlBb,SAA+BA,wLAEvBQ,EAAqCL,oBAEzCM,IAAKA,GAAYF,EACjBL,GAAI,YACU,CAACrB,GACb6B,KAAM,CAAC5B,GACP6B,kBAAmBX,EAAQM,gBAG3BJ,IAAIF,EAAQY,MAAQV,GACjBM,EAMcK,CAAsBf,EAASE,UAEpDc,EAAuChB,EAASE,SACzCF,wCA5DaiB,WACpBf,EACAgB,cAEAjB,EAA+BC,mBACxBiB,EAAUjB,EAAS,CACxBgB,OAAQA,EAAOE,IACfC,OAAQH,EAAOG,OACfC,IAAKJ,EAAOI,KFxCO,kDEoBDC,WACpBrB,EACAgB,cAEAF,EAAuCd,mBAChCiB,EAAUjB,EAAS,CACxBgB,OAAQA,EAAOE,IACfC,OAAQH,EAAOG,OACfC,IAAKJ,EAAOI,KF5BO,2DE4CPN,EACdd,GAEAsB,EAA2BtB,EAAQE,GAAG,sBDXTjB,MACzBA,EAAMO,OAAS,IAAMP,EAAMQ,SAASX,SAChC,IAAIK,sCAAsCL,OCUlDwC,CAA0BtB,EAAQE,GAAGQ,eDAGzB,MACN,IAA9BkB,OAAOoB,KCA0BvB,EAAQE,GAAGS,mBDAzBnB,aACf,IAAIL,UAAU,uCCDtBmC,GACItB,EAAQS,KAAKa,EAA6BtB,EAAQS,KAClDT,EAAQwB,KAAKF,EAA6BtB,EAAQwB,cAGxCzB,EAA+BC,MAC7CsB,EAA2BtB,EAAQyB,GAAG,sBDbTxC,MACzBA,EAAMO,OAAS,IAAMP,EAAMQ,SAASV,SAChC,IAAII,sCAAsCJ,OCYlDuC,CAA0BtB,EAAQyB,GAAGf,MACjCV,EAAQyB,GAAGC,qBAAqBlC,OAAS,QACrC,IAAIL,UAAU,iDAEjB,UAAYa,EAAQyB,GAAGC,qCAC1BJ,QAEEtB,EAAQwB,KAAKF,EAA6BtB,EAAQwB"}